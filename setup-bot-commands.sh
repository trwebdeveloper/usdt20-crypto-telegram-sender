#!/bin/bash

echo "ü§ñ Bot Komutlarƒ± Kurulumu Ba≈ülƒ±yor..."

# Bot Handlers - Start & Help
echo "üìù Bot handlers olu≈üturuluyor..."
cat > src/bot/handlers/basic.js << 'EOF'
const logger = require('../../utils/logger');
const db = require('../../database');

class BasicHandlers {
  
  static start() {
    return async (ctx) => {
      try {
        const user = ctx.from;
        logger.info(`Yeni kullanƒ±cƒ±: ${user.first_name} (${user.id})`);

        // Kullanƒ±cƒ±yƒ± veritabanƒ±na kaydet/g√ºncelle
        await db.User.upsert({
          telegram_id: user.id,
          username: user.username,
          first_name: user.first_name,
          last_activity: new Date()
        });

        const welcomeMessage = `ü§ñ *Crypto Bot'a Ho≈ü Geldiniz!*

Merhaba ${user.first_name}! üëã

üîπ *Ana Komutlar:*
/help - Yardƒ±m men√ºs√º
/wallet - C√ºzdan y√∂netimi 
/balance - Bakiye sorgula
/send - USDT g√∂nder
/history - ƒ∞≈ülem ge√ßmi≈üi

üîπ *G√ºvenlik:*
- Private key'leriniz ≈üifrelenmi≈ü saklanƒ±r
- ƒ∞≈ülemler i√ßin onay gerekir
- G√ºnl√ºk limitler mevcuttur

‚ö° Ba≈ülamak i√ßin /wallet komutunu kullanƒ±n!`;

        await ctx.reply(welcomeMessage, { parse_mode: 'Markdown' });
      } catch (error) {
        logger.error('Start komutu hatasƒ±:', error);
        await ctx.reply('‚ùå Bir hata olu≈ütu. L√ºtfen tekrar deneyin.');
      }
    };
  }

  static help() {
    return async (ctx) => {
      const helpMessage = `üìñ *Yardƒ±m Men√ºs√º*

üîπ *Temel Komutlar:*
/start - Bot'u ba≈ülat
/help - Bu yardƒ±m men√ºs√º
/ping - Baƒülantƒ± testi

üîπ *C√ºzdan Y√∂netimi:*
/wallet - C√ºzdan ana men√ºs√º
/addwallet - Yeni c√ºzdan ekle
/wallets - C√ºzdan listesi
/balance - Bakiye sorgula

üîπ *Transfer ƒ∞≈ülemleri:*
/send - USDT g√∂nder
/history - ƒ∞≈ülem ge√ßmi≈üi
/status - ƒ∞≈ülem durumu sorgula

üîπ *G√ºvenlik:*
/settings - G√ºvenlik ayarlarƒ±
/limits - G√ºnl√ºk limitler

üìû *Destek:* Sorun ya≈üƒ±yorsanƒ±z /ping komutu ile test edin.

‚ö†Ô∏è *√ñnemli:* Private key'lerinizi asla payla≈ümayƒ±n!`;

      await ctx.reply(helpMessage, { parse_mode: 'Markdown' });
    };
  }

  static ping() {
    return async (ctx) => {
      const startTime = Date.now();
      try {
        await ctx.reply('üèì Pong!');
        const endTime = Date.now();
        const responseTime = endTime - startTime;
        
        logger.info(`Ping komutu: ${responseTime}ms - User: ${ctx.from.id}`);
        
        if (responseTime > 1000) {
          await ctx.reply(`‚ö†Ô∏è Yava≈ü baƒülantƒ±: ${responseTime}ms`);
        }
      } catch (error) {
        logger.error('Ping komutu hatasƒ±:', error);
      }
    };
  }
}

module.exports = BasicHandlers;
EOF

# Wallet Handlers
echo "üìù Wallet handlers olu≈üturuluyor..."
cat > src/bot/handlers/wallet.js << 'EOF'
const walletService = require('../../blockchain/wallet');
const tronService = require('../../blockchain/tron');
const logger = require('../../utils/logger');
const { Markup } = require('telegraf');

class WalletHandlers {

  static walletMenu() {
    return async (ctx) => {
      try {
        const userId = ctx.from.id;
        const wallets = await walletService.getUserWallets(userId);

        const keyboard = Markup.inlineKeyboard([
          [Markup.button.callback('üíº C√ºzdanlarƒ±m', 'wallets_list')],
          [Markup.button.callback('‚ûï C√ºzdan Ekle', 'add_wallet')],
          [Markup.button.callback('üí∞ Bakiyeler', 'check_balances')],
          [Markup.button.callback('üìä ƒ∞≈ülem Ge√ßmi≈üi', 'transaction_history')]
        ]);

        const message = `üíº *C√ºzdan Y√∂netimi*

üìä Toplam c√ºzdan sayƒ±sƒ±: ${wallets.length}

Ne yapmak istiyorsunuz?`;

        await ctx.reply(message, {
          parse_mode: 'Markdown',
          reply_markup: keyboard.reply_markup
        });

      } catch (error) {
        logger.error('Wallet menu hatasƒ±:', error);
        await ctx.reply('‚ùå C√ºzdan men√ºs√º y√ºklenemedi.');
      }
    };
  }

  static walletsList() {
    return async (ctx) => {
      try {
        const userId = ctx.from.id;
        const wallets = await walletService.getUserWallets(userId);

        if (wallets.length === 0) {
          await ctx.editMessageText('üì≠ Hen√ºz hi√ß c√ºzdanƒ±nƒ±z yok.\n\n‚ûï C√ºzdan eklemek i√ßin /addwallet komutunu kullanƒ±n.');
          return;
        }

        let message = `üíº *C√ºzdanlarƒ±nƒ±z (${wallets.length} adet)*\n\n`;
        
        wallets.forEach((wallet, index) => {
          const shortAddress = `${wallet.address.substring(0, 6)}...${wallet.address.substring(-4)}`;
          message += `${index + 1}. *${wallet.name}*\n`;
          message += `   üìç \`${shortAddress}\`\n`;
          message += `   üìÖ ${new Date(wallet.created_at).toLocaleDateString('tr-TR')}\n\n`;
        });

        const keyboard = Markup.inlineKeyboard([
          [Markup.button.callback('üí∞ Bakiyeleri G√∂ster', 'check_balances')],
          [Markup.button.callback('‚¨ÖÔ∏è Ana Men√º', 'wallet_menu')]
        ]);

        await ctx.editMessageText(message, {
          parse_mode: 'Markdown',
          reply_markup: keyboard.reply_markup
        });

      } catch (error) {
        logger.error('Wallet list hatasƒ±:', error);
        await ctx.reply('‚ùå C√ºzdan listesi alƒ±namadƒ±.');
      }
    };
  }

  static checkBalances() {
    return async (ctx) => {
      try {
        const userId = ctx.from.id;
        
        await ctx.editMessageText('üîÑ Bakiyeler kontrol ediliyor, l√ºtfen bekleyin...');
        
        const walletsWithBalances = await walletService.getWalletBalances(userId);

        if (walletsWithBalances.length === 0) {
          await ctx.editMessageText('üì≠ Hen√ºz hi√ß c√ºzdanƒ±nƒ±z yok.');
          return;
        }

        let message = `üí∞ *C√ºzdan Bakiyeleri*\n\n`;
        let totalUsdt = 0;
        let totalTrx = 0;

        walletsWithBalances.forEach((wallet, index) => {
          const shortAddress = `${wallet.address.substring(0, 6)}...${wallet.address.substring(-4)}`;
          message += `${index + 1}. *${wallet.name}*\n`;
          message += `   üìç \`${shortAddress}\`\n`;
          
          if (wallet.balances.error) {
            message += `   ‚ùå ${wallet.balances.error}\n\n`;
          } else {
            message += `   üíµ ${wallet.balances.usdt} USDT\n`;
            message += `   ‚ö° ${wallet.balances.trx} TRX\n\n`;
            totalUsdt += wallet.balances.usdt;
            totalTrx += wallet.balances.trx;
          }
        });

        message += `üìä *Toplam Bakiye:*\n`;
        message += `üíµ ${totalUsdt.toFixed(6)} USDT\n`;
        message += `‚ö° ${totalTrx.toFixed(6)} TRX`;

        const keyboard = Markup.inlineKeyboard([
          [Markup.button.callback('üîÑ Yenile', 'check_balances')],
          [Markup.button.callback('‚¨ÖÔ∏è Ana Men√º', 'wallet_menu')]
        ]);

        await ctx.editMessageText(message, {
          parse_mode: 'Markdown',
          reply_markup: keyboard.reply_markup
        });

      } catch (error) {
        logger.error('Balance check hatasƒ±:', error);
        await ctx.editMessageText('‚ùå Bakiyeler alƒ±namadƒ±. L√ºtfen tekrar deneyin.');
      }
    };
  }

  static addWalletStart() {
    return async (ctx) => {
      try {
        const message = `‚ûï *Yeni C√ºzdan Ekleme*

üîê *G√ºvenlik Uyarƒ±sƒ±:*
- Private key'inizi sadece g√ºvenilir kaynaklardan alƒ±n
- Private key'iniz ≈üifrelenmi≈ü olarak saklanacak
- Bu bilgiyi kimseyle payla≈ümayƒ±n

üìù Private key'inizi g√∂nderin:`;

        await ctx.reply(message, { parse_mode: 'Markdown' });
        
        // Kullanƒ±cƒ±yƒ± "waiting_private_key" durumuna al
        // Bu kƒ±sƒ±m session/scene ile yapƒ±lacak

      } catch (error) {
        logger.error('Add wallet start hatasƒ±:', error);
        await ctx.reply('‚ùå C√ºzdan ekleme i≈ülemi ba≈ülatƒ±lamadƒ±.');
      }
    };
  }
}

module.exports = WalletHandlers;
EOF

# Send USDT Handlers
echo "üìù Send handlers olu≈üturuluyor..."
cat > src/bot/handlers/send.js << 'EOF'
const walletService = require('../../blockchain/wallet');
const tronService = require('../../blockchain/tron');
const logger = require('../../utils/logger');
const { Markup } = require('telegraf');

class SendHandlers {

  static sendMenu() {
    return async (ctx) => {
      try {
        const userId = ctx.from.id;
        const wallets = await walletService.getUserWallets(userId);

        if (wallets.length === 0) {
          await ctx.reply('üì≠ USDT g√∂ndermek i√ßin √∂nce c√ºzdan eklemelisiniz.\n\n‚ûï /addwallet komutu ile c√ºzdan ekleyin.');
          return;
        }

        let message = `üí∏ *USDT G√∂nderme*\n\n`;
        message += `Hangi c√ºzdandan g√∂ndermek istiyorsunuz?\n\n`;

        const buttons = wallets.map((wallet, index) => {
          const shortAddress = `${wallet.address.substring(0, 6)}...${wallet.address.substring(-4)}`;
          return [Markup.button.callback(`${index + 1}. ${wallet.name} (${shortAddress})`, `send_from_${wallet.id}`)];
        });

        buttons.push([Markup.button.callback('‚¨ÖÔ∏è Ana Men√º', 'wallet_menu')]);

        const keyboard = Markup.inlineKeyboard(buttons);

        await ctx.reply(message, {
          parse_mode: 'Markdown',
          reply_markup: keyboard.reply_markup
        });

      } catch (error) {
        logger.error('Send menu hatasƒ±:', error);
        await ctx.reply('‚ùå G√∂nderme men√ºs√º y√ºklenemedi.');
      }
    };
  }

  static sendTransactionConfirm() {
    return async (ctx, walletId, toAddress, amount) => {
      try {
        const userId = ctx.from.id;
        
        // C√ºzdan bilgisini al
        const wallets = await walletService.getUserWallets(userId);
        const wallet = wallets.find(w => w.id === walletId);
        
        if (!wallet) {
          await ctx.reply('‚ùå C√ºzdan bulunamadƒ±.');
          return;
        }

        // Bakiye kontrol et
        const balance = await tronService.getUsdtBalance(wallet.address);
        
        if (parseFloat(balance) < parseFloat(amount)) {
          await ctx.reply(`‚ùå Yetersiz bakiye!\n\nMevcut: ${balance} USDT\nG√∂ndermek istenen: ${amount} USDT`);
          return;
        }

        // Fee tahmini
        const feeInfo = await tronService.estimateUsdtTransferFee();

        const shortFromAddress = `${wallet.address.substring(0, 6)}...${wallet.address.substring(-4)}`;
        const shortToAddress = `${toAddress.substring(0, 6)}...${toAddress.substring(-4)}`;

        const confirmMessage = `‚úÖ *ƒ∞≈ülem Onayƒ±*

üì§ *G√∂nderen:* ${wallet.name}
üìç \`${shortFromAddress}\`

üì• *Alƒ±cƒ±:*
üìç \`${shortToAddress}\`

üí∞ *Miktar:* ${amount} USDT
‚õΩ *Tahmini Fee:* ~${feeInfo.estimatedFee} TRX

üîê Bu i≈ülemi onaylƒ±yor musunuz?`;

        const keyboard = Markup.inlineKeyboard([
          [
            Markup.button.callback('‚úÖ Onayla', `confirm_send_${walletId}_${amount}_${toAddress}`),
            Markup.button.callback('‚ùå ƒ∞ptal', 'send_cancel')
          ]
        ]);

        await ctx.reply(confirmMessage, {
          parse_mode: 'Markdown',
          reply_markup: keyboard.reply_markup
        });

      } catch (error) {
        logger.error('Send confirm hatasƒ±:', error);
        await ctx.reply('‚ùå ƒ∞≈ülem onayƒ± hazƒ±rlanamadƒ±.');
      }
    };
  }

  static executeSend() {
    return async (ctx, walletId, amount, toAddress, masterPassword) => {
      try {
        const userId = ctx.from.id;

        await ctx.editMessageText('üîÑ ƒ∞≈ülem ger√ßekle≈ütiriliyor, l√ºtfen bekleyin...');

        const result = await walletService.sendUsdt(userId, walletId, toAddress, amount, masterPassword);

        const successMessage = `‚úÖ *ƒ∞≈ülem Ba≈üarƒ±yla G√∂nderildi!*

üîó *Transaction Hash:*
\`${result.txHash}\`

üìä *Detaylar:*
üí∞ Miktar: ${amount} USDT
üì§ G√∂nderen: \`${result.from.substring(0, 8)}...\`
üì• Alƒ±cƒ±: \`${toAddress.substring(0, 8)}...\`
üìÖ Zaman: ${new Date().toLocaleString('tr-TR')}

‚è≥ ƒ∞≈ülem aƒüda onaylanƒ±yor...
/status komutu ile durumu takip edebilirsiniz.`;

        await ctx.editMessageText(successMessage, { parse_mode: 'Markdown' });

        logger.info(`USDT transfer ba≈üarƒ±lƒ±: ${amount} USDT - User: ${userId} - TX: ${result.txHash}`);

      } catch (error) {
        logger.error('Execute send hatasƒ±:', error);
        
        let errorMessage = '‚ùå ƒ∞≈ülem ba≈üarƒ±sƒ±z oldu.\n\n';
        
        if (error.message.includes('Yetersiz bakiye')) {
          errorMessage += 'üí∞ Yetersiz bakiye.';
        } else if (error.message.includes('Ge√ßersiz')) {
          errorMessage += 'üìç Ge√ßersiz adres.';
        } else if (error.message.includes('≈ûifre')) {
          errorMessage += 'üîê ≈ûifre hatasƒ±.';
        } else {
          errorMessage += `üîç Hata: ${error.message}`;
        }

        await ctx.editMessageText(errorMessage);
      }
    };
  }
}

module.exports = SendHandlers;
EOF

# Main Bot Index
echo "üìù Bot ana dosyasƒ± olu≈üturuluyor..."
cat > src/bot/index.js << 'EOF'
const { Telegraf, Markup } = require('telegraf');
const BasicHandlers = require('./handlers/basic');
const WalletHandlers = require('./handlers/wallet');
const SendHandlers = require('./handlers/send');
const logger = require('../utils/logger');

class CryptoBot {
  constructor(token) {
    this.bot = new Telegraf(token);
    this.setupHandlers();
    this.setupCallbacks();
    this.setupErrorHandling();
  }

  setupHandlers() {
    // Basic commands
    this.bot.start(BasicHandlers.start());
    this.bot.help(BasicHandlers.help());
    this.bot.command('ping', BasicHandlers.ping());

    // Wallet commands
    this.bot.command('wallet', WalletHandlers.walletMenu());
    this.bot.command('wallets', WalletHandlers.walletsList());
    this.bot.command('balance', WalletHandlers.checkBalances());
    this.bot.command('addwallet', WalletHandlers.addWalletStart());

    // Send commands
    this.bot.command('send', SendHandlers.sendMenu());

    // History and status commands
    this.bot.command('history', (ctx) => {
      ctx.reply('üìä ƒ∞≈ülem ge√ßmi≈üi √∂zelliƒüi yakƒ±nda eklenecek...');
    });

    this.bot.command('status', (ctx) => {
      ctx.reply('üîç ƒ∞≈ülem durumu sorgulama √∂zelliƒüi yakƒ±nda eklenecek...');
    });
  }

  setupCallbacks() {
    // Wallet callbacks
    this.bot.action('wallet_menu', WalletHandlers.walletMenu());
    this.bot.action('wallets_list', WalletHandlers.walletsList());
    this.bot.action('check_balances', WalletHandlers.checkBalances());
    this.bot.action('add_wallet', WalletHandlers.addWalletStart());

    // Send callbacks
    this.bot.action(/^send_from_(\d+)$/, (ctx) => {
      const walletId = ctx.match[1];
      ctx.reply(`üìù Hedef adres girin:\n\n‚ö†Ô∏è TRON (TRC20) adresini dikkatli girin!`);
      // Session handling burada olacak
    });

    this.bot.action('send_cancel', (ctx) => {
      ctx.editMessageText('‚ùå ƒ∞≈ülem iptal edildi.');
    });

    // Generic callback for unknown actions
    this.bot.on('callback_query', (ctx) => {
      if (!ctx.callbackQuery.data.match(/^(wallet_|send_|check_|add_)/)) {
        ctx.answerCbQuery('üöß Bu √∂zellik hen√ºz hazƒ±r deƒüil...');
      }
    });
  }

  setupErrorHandling() {
    this.bot.catch((err, ctx) => {
      logger.error('Bot hatasƒ±:', err);
      
      if (ctx.updateType === 'callback_query') {
        ctx.answerCbQuery('‚ùå Bir hata olu≈ütu');
        ctx.editMessageText('‚ùå Bir hata olu≈ütu. L√ºtfen tekrar deneyin.');
      } else {
        ctx.reply('‚ùå Bir hata olu≈ütu. L√ºtfen tekrar deneyin.');
      }
    });

    // Handle text messages for commands
    this.bot.on('text', (ctx) => {
      const text = ctx.message.text;
      
      if (!text.startsWith('/')) {
        ctx.reply('üí° Komut listesi i√ßin /help yazƒ±n.');
      }
    });
  }

  async launch() {
    await this.bot.launch();
    logger.info('ü§ñ Crypto Bot ba≈ülatƒ±ldƒ±');
    return this.bot;
  }

  stop(reason) {
    this.bot.stop(reason);
    logger.info(`üõë Bot durdu: ${reason}`);
  }
}

module.exports = CryptoBot;
EOF

echo "‚úÖ Bot komutlarƒ± ba≈üarƒ±yla olu≈üturuldu!"
echo "üîÑ Artƒ±k app.js dosyasƒ±nƒ± g√ºncelleyebilirsiniz!"
